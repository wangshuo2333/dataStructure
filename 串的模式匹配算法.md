#### 串的模式匹配算法
- 子串的定位操作通常称作串的模式匹配

> 假设要从下面的主串 S = “goodgoogle”中，找到 T = “google”这个子串的位置 。通常需要下面几个步骤
> 1. 主串S第一位开始，S与T前三个字母都匹配成功，但S第四个字母是d而T的是g。第一位匹配失败。如图5-6-1所示，其中竖直连线表示相等，闪电状弯折连线表示不登。
> ![enter description here][1]
> 2. 主串S第二位开始，主串S首字母是o，要匹配的T首字母是g，匹配失败，如图5-6-2所示。
> ![enter description here][2]
> 3. 主串S第三位开始，主串S首字母是o，要匹配的T首字母是g，匹配失败
> ![enter description here][3]
> 4. 主串S第四位开始，主串S首字母是d，要匹配的T首字母是g，匹配失败
> ![enter description here][4]
> 5. 主串S第五位开始，S与T，6个字母全匹配，匹配成功
> ![enter description here][5]
> 简单地说，就是对主串的每一个字符作为子串开头，与要匹配的字符串进行匹配。对主串做大循环，每个字符开头做T的长度的小循环，知道匹配成功或全部遍历完成为止。
> ![enter description here][6]
> ![enter description here][7]
> 分析一下，最好的情况是什么？那就是一开始就匹配成功，比如“goodgoogle”中去找“google”，时间复杂度为O(1)。稍差一些，如果像刚才例子中第二、三、四位一样，每次都是首字母就不匹配，那么对T串的循环就不必进行了，比如“abcdefgoogle”中去找“google”。那么时间复杂度为O(m+n)
，其中n为主串长度，m为要匹配的子串长度。根据等概率原则，评价是（n+m）/2次查找，时间复杂度为O(n+m)。
> 那么最坏的情况又是什么？那就是每次不成功的匹配都发送在串T的最后一个字符。举一个很极端的例子。主串S = "0000000001"，而要匹配的子串为T = “000001”，前者是有49个0和1个1的主串，后者是9个0和1个1的子串。在匹配时，每次都得将T中字符串循环到最后一位才发现不匹配。这样等于T串需要在S串的钱40个位置都需要判断10次，并得出不匹配的结论
> ![enter description here][8]
> 直到最后第41个位置，因为全部匹配相等，所以不需要再继续进行下去，如图6-5-7所示。如果最终没有可匹配的子串，比如 T = “0000002”，到了第41位置判断不匹配后同样不需要继续对比下去。因此最坏情况的时间复杂度为O((n-m+1)*m)。
> ![enter description here][9]
> 在实际应用中，对于计算机来说，处理的都是二进制位的0和1的串，一个字符的ASCII码也可以看成8位的二进制位01串。再比如计算机图形也可以理解为是有许许多多个0和1的串组成。所以在计算机的运算当中，模式匹配操作可说是随处可见，而模式匹配算法，就显得太低效了。


  [1]: ./images/1510731546178.jpg
  [2]: ./images/1510731596172.jpg
  [3]: ./images/1510731630745.jpg
  [4]: ./images/1510731688938.jpg
  [5]: ./images/1510731721728.jpg
  [6]: ./images/1510731891912.jpg
  [7]: ./images/1510731902041.jpg
  [8]: ./images/1510732364280.jpg
  [9]: ./images/1510732484056.jpg