### 队列的定义与循环队列

- 队列是只允许在一端进行插入操作，而在另一端进行删除操作的线性表。
- 队列是一种先进先出的线性表，简称FIFO。允许插入的一端称为队尾，允许删除的一端称为队头。
> 假设队列是 q = （a1, a2 ''''' , an），那么a1是队头元素，而an是队尾元素，这样就可以删除时总是从a1开始，而插入时，列在最后。这也比较符合日常生活中，排在第一个的优先出列，最后来的当然排在队伍最后
![enter description here][1]

#### 队列的抽象数据类型

> 同样是线性表，队列也有类似线性表的各种操作，不同的就是插入数据只能在队尾进行，删除数据只能在队头进行。
![enter description here][2]

#### 循环队列

> 线性表有顺序存储和链式存储，栈是线性表，所以有这两种存储方式。同样，队列作为一种特殊的线性表，也同样存在这两种存储方式。

- 队列顺序存储的不足

> 假设一个队列有n个元素，则顺序存储的队列需要建立一个大于n的数组，并把队列的所有元素存储在数组的前n个单元，数组下标为0的一端即是队头。所谓的入队列操作，其实就是在队尾追加一个元素，不需要移动任何元素，因此时间复杂的为O(1)
![enter description here][3]
> 与栈不同的是，队列元素的出列是在队头，即下标为0的位置，那也就意味着，队列中的所有元素都得向前移动，以保证队列的队头，也就是下标为0的位置不为空，此时间复杂度为O(n)
![enter description here][4]
> 可有时想想，为什么出队列时一定要全部移动呢，如果不去限制队列元素必须存储在数组的前n个单元这一条件，出队的性能就会大大增加。也就是说，队头不需要一定在下标为0的位置
![enter description here][5]
> 为了避免当只有一个元素时，队头和队尾重合使处理变得麻烦，所以引入两个指针，front指针指向队头元素，rear指针指向队尾元素的下一个位置，这样当front等于rear时，此队列不是还剩一个元素，而是空队列。
> 假设是长度为5的数组，初始状态，空队列如图4-12-4的左图所示，front与rear指针均指向下标为0的位置。然后入队a1,a2,a3,a4,front指针依然指向下标为0的位置，而rear指针指向下标为4的位置，如图4-12-4的右图所示
![enter description here][6]
> 出队a1，a2，则front指针指向下标为2的位置，rear不变，如图4-12-5的左图所示，再入队a5，此时front指针不变。rear指针移动到数组之外。数组之外？将是哪里？
![enter description here][7]
> 问题还远不止如此。假设这个队列的总个数不超过5个，但目前如果接着入队的话，因数组末尾元素已经占用，再向后加，就会产生数组越界的错误，可实际上，我们队列在下标为0和1的地方还是空闲的。我们把这种现象叫做“假溢出”。

- 循环队列定义
> 所以解决假溢出的办法就是后面满了，就再从头开始，也就是头尾相接的循环。我们把队列的这种头尾相接的循环存储结构称为循环队列。
> 刚才的例子继续，图4-12-5的rear可以改为指向下标为0的位置，这样就不会造成指针指向不明的问题了，如图4-12-6所示。
![enter description here][8]
> 单是顺序存储，若不是循环队列，宣发的时间性能不高，但循环队列又面临着数组可能会溢出的问题，所以还是需要研究一下不需要担心队列长度的链式存储结构。

  [1]: ./images/1510642540673.jpg
  [2]: ./images/1510642649898.jpg
  [3]: ./images/1510642929257.jpg
  [4]: ./images/1510643058650.jpg
  [5]: ./images/1510643161577.jpg
  [6]: ./images/1510643500963.jpg
  [7]: ./images/1510643629421.jpg
  [8]: ./images/1510644064554.jpg