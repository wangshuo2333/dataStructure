### 栈的链式存储结构及实现

- 栈的链式存储结构，简称链栈
> 栈指示栈顶来做插入和删除操作，栈顶放在链表的头部还是尾部呢？由于单链表有头指针，而栈顶指针也是必须的，他俩是可以合二为一的，所以比较好的办法时把栈顶放在单链表的头部，另外，都已经有了栈顶在头部了，单链表中比较常用的头结点也就失去了意义，通常对于链表来说，是不需要头结点的。
> ![enter description here][1]
> 对于链表来说，基本不存在栈满的情况，除非内存已经没有可以使用的空间，如果真的发生，那此时的鸡阿U是哪家系统已经面临崩溃的情况，而不是链栈是否溢出的问题
> 链栈代码如下
> ![enter description here][2]
> 链栈的操作绝大多数部分都和单链表类似，只是在插入和删除上特殊一些

#### 栈的链式存储结构——进栈操作
> 对于链栈的进栈push操作，假设元素值为e的新节点时s， top的为栈顶指针，所示代码如下
> ![enter description here][3]

``` c
//插入元素e为新的栈顶元素
Status Push(LinkStack *S, SElemType e)
{
	LinkSrackPtr s = (LinkStackPtr)malloc(sizeof(StackNode));
	s->data = e;
	s->next = s->top;//把当前的栈顶元素赋值个i新节点的直接后继
	S->top = s;//将新的节点s赋值个栈顶指针
	S->count++;
	return OK;
}
```
#### 栈的链式存储操作——出栈操作
> 至于链栈的出栈pop操作，也是很简单的三句操作。假设p用来存储要删除的栈顶节点，将栈顶指针下移一位，最后释放p即可
> ![enter description here][4]
> ![enter description here][5]
> 
> 链栈的进栈push和出栈的pop操作都很简单，没有任何循环操作，时间复杂度均为O（1）
> 对比一下顺序栈与链栈，他们在时间复杂度上是一样的，均为O（1）。对于空间性能，顺序栈需要事先确定一个固定的长度，可能会存在内存空间的浪费问题。单它的优势是存取时定位很方便，而链栈则要求每个元素都有指针域，这同时也增加了一些内存开销，但对于栈的长度无限制。所以他们的区别和线性表中讨论的一样**如果栈的使用过程中元素变化不可预料，有时很小，有时非常大，那么最好使用链栈，反之，如果它的变化在可控范围内，建议使用顺序栈会更好一些**。


  [1]: ./images/1510553449348.jpg
  [2]: ./images/1510553565088.jpg
  [3]: ./images/1510553678136.jpg
  [4]: ./images/1510554059948.jpg
  [5]: ./images/1510554080214.jpg