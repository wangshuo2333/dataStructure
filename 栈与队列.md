### 栈与队列
- 栈的限定仅在标尾进行插入和删除操作的线性表
- 队列时只允许在一段进行插入操作,而在另一端进行删除操作的线性表

### 栈

- 栈的定义
> 先进后出,后进先出的数据结构
> *栈是限定仅在表尾进行插入和删除操作的线性表*
> 我们把允许插入和删除的一端称为栈顶,另一端称为栈底,不含任何数据元素的栈称为空栈.栈又称为后进先出的线性表,简称LIFO结构
> 首先它是一个线性表,也就是说栈元素具有线性关系,即前驱后继关系.只不过它是一种特殊的线性表而已.定义中说是在线性表的表尾进行插入和删除操作这里表尾指栈顶,而不是栈底
> 它的特殊之处就在于限制了这个线性表的插入和删除位置,它始终只在栈顶进行.这就使得：栈底时固定的，最先进栈的只能在栈底。
> 栈的插入操作，叫做进栈，也称压栈、入栈
> 栈的删除操作，叫做出栈，也有叫做弹栈
> ![enter description here][1]

- 进栈出栈的变化形式
> 最先进栈的元素,是不是只能最后出栈呢?
> 答案是不一定。栈对线性表的掺入和删除的位置进行了限制，并没有对元素进出的时间进行限制，也就是说，在不是所有元素都进栈的情况下，事先进入的元素也可以出栈，只要保证是栈顶元素出栈就可以
> 举例来说，如果我们现在有三个整形元素1、2、3依次进栈，会有哪些出栈次序呢
>  1.  第一种：1、2、3进，再3、2、1出。这是最简单最好理解的一种，出栈次序为321
>  2. 第二种：1进，1出，2进，2出，3进，3出。也就是进一个出一个，出栈次序为123
>  3. 第三种：1进，2进，2出，1出，3进，3出。出栈次序为213
>  4. 第四种：1进，1出，2进，3进，3出，2出。出栈次序为132
>  5. 第五种：1进，2进，2出，3进，3出，1出。出栈次序为231
>  有没有可能是312这样的次序出栈呢？答案是肯定不会。因为3先出栈，就意味着，3曾经进栈，既然3都进栈了，那也就意味着，1和2已经进栈了，此时，2一定是在1的上面，就是更接近栈顶，那么出栈只可能时321，不然不满足123依次进栈的要求，所以此时不会发生1比2先出栈的情况。

#### 栈的顺序存储结构
> 既然栈是线性表的特例，那么栈的数据存储结构其实也是线性表顺序存储的简化，简称为顺序栈。
> 将数组下标为0的一端作为栈底，因为受元素都存在栈底，变化最小
> 定义一个top变量来指示栈顶元素在数组的位置，栈顶的top可以变大变小但不能超过存储栈的长度。若存储栈的长度为StackSize，则栈顶位置top必须小于StackSize。当栈存在一个元素时，top等于0，因此通常把空栈的判定条件定位top等于-1.
> ![enter description here][2]
> 若现在有一个栈，StackSize是5，则栈普通情况、空栈和栈满的情况示意图如下
> ![enter description here][3]

- 栈的顺序存储结构——进栈操作
> 对于栈的插入。即进栈操作，其实就是做了如图所示的处理
> ![enter description here][4]
> 因此丢进栈操作push，其代码如下

``` c
//插入元素e为新的栈顶元素
Status Push(SqStack *S, SElemType e)
{
	if(s->top == MAXSIZE - 1)
	{
		return ERROR;
	}
	S->stop++; //栈顶指针增加一
	S->data[S->stop] = e //将新插入的元素赋值给栈顶空间
	return OK;
}
```

#### 栈的顺序存储结构——出栈操作
> 出栈操作pop，代码如下

``` c
//若栈不空，则删除S的栈顶元素，用e返回其值，病返回OK；否则返回ERROR
Status Pop(SqStack *S, SElemType *e)
{
	if(S->top == -1)
	{
		retuen ERROR;
	}
	*e = S->data[S->top]; //将要删除的栈顶元素赋值给e
	S->top--;  //栈顶指针减一
	return OK;
}
```

*两者么有涉及到任何循环语句，因此时间复杂度均是O（1）*

### 两栈共享空间

> 其实栈的顺序存储还是很方便的，因为它只准栈顶进出元素，所以不存在线性表插入和删除时需要移动元素的问题，不过它有一个很大的缺陷，就是必须事先确定数组存储空间大小，万一不够用了，就需要编程手段来扩展数组的容量，非常麻烦。对于一个栈我们也只能尽量考虑周全，设计出合适大小的数组来处理，单对于两个相同类型的栈，我们却可以做到最大限度地利用其实现开辟的存储空间来进行操作。
> 如果我们又两个相同类型的栈，我们为他们各自开辟了数组空间，极有可能第一个栈已经满了，再进栈就溢出了，而另一个栈还有很多存储空间。这又何必呢，我们完全可以用一个数组来存储两个栈
> 做法如下图，数组又两个端点，两个栈又两个栈底，让一个栈的栈底为数组的始端，即下标为0处，另一个栈为栈的末端，即下标为数组长度n-1处。这样，两个栈如果增加元素，就是两端点向中间延伸。
> ![enter description here][5]
> 关键思路： 他们实在数组的两端，向中间靠拢。top1和top2时栈1和栈2的栈顶指针，可以想象，只要他俩不见面，两个栈就可以一直使用。
> 从这里也就可以分析出来，栈1为空时，就是top1等于-1时；而当top2等于n时，即是栈2为空时，那什么时候栈满呢？
> 想想极端情况，若栈2为空栈，栈1的top1等于n-1时就是栈1满了。反之当栈1为空栈时，top2等于0时，为栈2满。其实就是两个栈见面指示，也就是两个指针之间相差1时，即top1 + 1 == top2为栈满。
> 两栈共享空间的结构代码如下

``` c
//两栈共享空间结构
typedef struct
{
	SElemType data[MAXSIZE];
	int top1; //栈1栈顶指针
	int top2; //栈2栈顶指针
}SqDoubleStack;
```
> 对于两栈共享空间的push方法，除了要插入元素值参数外，还需要有一个判断是栈1还是栈2的栈号参数stackNumber.插入元素的代码如下：

``` c
//插入元素e为新的栈顶元素
Status Push (SqDoublStack *S, SElemType e, int stackNumber)
{
	if(S->top1 + 1 == S->top2)//栈已满，不能再push新元素了
	{
		return ERROR;
	}
	if(stackNumber == 1) //栈1有元素进栈
	{
		S->data[++S->top1] = e; //若栈1则先top+1后给数组元素赋值		
	}else if(stackNumber == 2){// 栈2有元素进栈
		S->data[--S->top2 = e;// 若栈2则先top2-1后给数组元素赋值]
	}
	return OK;
}
```
> 因为现在开始已经判断了是否有栈满的情况，所以后面的top1 + 1或top2-1是不大新溢出问题的
> 对于两栈共享空间的pop方法，参数指示判断栈1栈2的参数stackNumber
> ![enter description here][6]
> 事实上，使用这样的数据结构，通常都是当两个栈的空间需求有相反关系时，也就是一个栈增长时另一个栈在缩短的情况。就像买卖股票一样，你买入时，一定时有一个人在卖出。这样使用两栈共享空间存储方法才比较有意义。否则两个栈都在不停增长，那很快就会因栈满而溢出。


  [1]: ./images/1510280206104.jpg
  [2]: ./images/1510294298282.jpg
  [3]: ./images/1510294360756.jpg
  [4]: ./images/1510294442625.jpg
  [5]: ./images/1510297042033.jpg
  [6]: ./images/1510551621552.jpg